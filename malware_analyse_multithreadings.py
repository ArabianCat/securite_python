import yara
import json
import concurrent.futures

# Définir la fonction pour générer un rapport
def generate_report(file_path, matches):
    report = {
        'file': file_path,
        'matches': [match.rule for match in matches]
    }
    with open("report.json", "a") as report_file:
        json.dump(report, report_file)
        report_file.write("\n")

# Fonction de scan (permet de scanner un fichier en fonction des règles)
def scan_file(path, rules_file):
    rule = yara.compile(rules_file)
    matches = rule.match(path)
    if matches:
        print(f"Les règles Yara ont trouvé des correspondances dans {path} :")
        for match in matches:
            print(f"Règle correspondante : {match.rule}")
        generate_report(path, matches)
    else:
        print(f"Aucune correspondance trouvée dans {path}.")

# Demander le chemin des fichiers à scanner (vous pouvez scanner plusieurs fichiers)
print("Quels sont les chemins des fichiers que vous voulez scanner (séparés par une virgule) ?")
paths = input().split(',')

# Demande la catégorie de scan
choix1 = ''
while choix1 != '1' and choix1 != '2':
    print("Quelle catégorie de scan veux-tu faire ?")
    print("1. Malware")
    print("2. Ransomware")
    choix1 = input()
    if choix1 != '1' and choix1 != '2':
        print("Veuillez rentrer 1 ou 2.")

# Demande le type de scan
choix2 = ''
while choix2 != '1' and choix2 != '2':
    print("Quel type de scan veux-tu faire ?")
    print("1. Simple")
    print("2. Avancée")
    choix2 = input()
    if choix2 != '1' and choix2 != '2':
        print("Veuillez rentrer 1 ou 2.")

# Sélection des fichiers Yara en fonction du choix de l'utilisateur
rule_file = ''
if choix1 == '1':
    rule_file = '000_common_rules.yar' if choix2 == '1' else 'malware_index.yar'
elif choix1 == '2':
    rule_file = 'ransomware_index.yar'

# Utilise le multithreading pour scan plusieurs fichiers en simultanée
with concurrent.futures.ThreadPoolExecutor() as executor:
    futures = {executor.submit(scan_file, path.strip(), rule_file): path for path in paths}

    for future in concurrent.futures.as_completed(futures):
        file_path = futures[future]
        try:
            future.result()  # On récupère les résultats de chaque scan
        except Exception as exc:
            print(f"{file_path} a généré une exception: {exc}")